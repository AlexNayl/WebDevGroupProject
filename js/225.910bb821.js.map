{"version":3,"file":"js/225.910bb821.js","mappings":"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","sources":["webpack://webdevgroupproject/./src/views/WordSearchView.vue","webpack://webdevgroupproject/./src/components/WordSearchGame.vue","webpack://webdevgroupproject/./public/scripts/WordSearch.js","webpack://webdevgroupproject/./src/components/WordSearchGame.vue?1823","webpack://webdevgroupproject/./src/views/WordSearchView.vue?353f"],"sourcesContent":["<template>\n\t<div class=\"WordSearch\">\n\t\t<h1>Word Search</h1>\n\t\t<WordSearchGame />\n\t</div>\n</template>\n\n<script>\n\timport WordSearchGame from '@/components/WordSearchGame.vue'\n\texport default {\n\t\tname: \"WordSearch\",\n\t\ttitle: \"WordSearch\",\n\t\tcomponents: {\n\t\t\tWordSearchGame,\n\t\t},\n\t}\n</script>\n","<template>\n\t<p>\n\t\tFind the hidden words on the board. They are placed horizontally, vertically, or diagonally, possibly reversed.\n\t</p>\n\t<p>Time: {{time}}</p>\n\t<div>\n\t\t<button @click=\"reset\" id=\"resetButton\">New Game</button>\n\t</div>\n\n\t<div id=\"game\"></div>\n</template>\n\n<script>\n\timport * as aws from \"@/../public/scripts/WordSearch.js\";\n\texport default{\n\t\tname: \"WordSearchGame\",\n\t\tdata(){\n\t\t\treturn {\n\t\t\t\tgame: null,\n\t\t\t\tboardSize: 0,\n\t\t\t\ttime: 0,\n\t\t\t}\n\t\t},\n\t\tmethods: {\n\t\t\tstartup: function() {\n\t\t\t\tthis.game = new aws.WordSearch(this);\n\t\t\t},\n\t\t\treset: function(){\n\t\t\t\tif (!this.game){ return; }\n\t\t\t\tthis.game.reset();\n\t\t\t}\n\t\t},\n\t\tmounted(){\n\t\t\tthis.$nextTick( () => {\n\t\t\t\tthis.startup();\n\t\t\t});\n\t\t}\n\t}\n</script>\n","/* \n * File: WordSearch.js\n * Function: main file containing key functions to run word search game\n * Authors: Bencs, Tacaks, Zachary Windover, Samuel Jones\n */\n\n\nimport p5 from \"p5\";\nimport accessHighscores from './access_highscores.js';\n\n\n// defining arrays of possible puzzle words\nconst WORD_SELECTIONS = \n[\n['SCOPE', 'let', 'HTML', 'COBOL', 'UTIL'],\n['CODE', 'CSS', 'JAVA', 'SWIFT', 'STACK'],\n['CLANCY', 'DAVINCI', 'HAMILTON', 'TESLA', 'TURING'],\n['YUKIHIRO', 'SATOSHI', 'GOSLING', 'BJARNE'],\n['DOG', 'CAT', 'ORCA', 'FOX', 'SQUID', 'WOLF', 'FALCON', 'PENGIUN'],\n['ACTION', 'HORROR', 'COMEDY', 'DRAMA', 'THRILLER', 'SCIFI', 'ROMANCE', 'CRIME'],\n['PINE', 'MAPLE', 'BIRCH', 'OAK', 'GINKO', 'CHERRY', 'SEQUOIA', 'ASH', 'SPRUCE'],\n['DEADPOOL', 'SUPERMAN', 'BATMAN', 'IRONMAN', 'ANTMAN', 'FLASH', 'HULK'],\n['VENENO', 'HURACAN', 'JESKO', 'SENNA', 'CHIRON', 'DIVO', 'ENZO', 'STRADALE', 'BATTISTA', 'CHARGER'],\n['STARSHIP', 'NEWGLENN', 'FALCON', 'ELECTRON', 'ANTARES', 'ARES', 'MINOTAUR', 'DELTA', 'ATLAS', 'ATHENA',\n                        'PEGASUS', 'TITAN', 'SATURN', 'COLUMBIA', 'ATLANTIS'],\n['ROSE', 'DAISY', 'LILAC', 'LILY', 'IRIS', 'JASMINE', 'POPPY', 'TULIP', 'LAVENDER',\n                        'PEONY', 'PRIMROSE', 'ORCHID'],\n['COFFEE', 'TEA', 'BOBA', 'WATER', 'JUICE', 'WINE', 'VODKA', 'WHISKEY',\n                        'RUM', 'SMOOTHIE', 'SODA', 'BEER', 'LEMONADE', 'MILK'],\n['UKRAINE', 'TAIWAN', 'INDIA', 'FINLAND', 'SWEDEN', 'DENMARK', 'NORWAY', 'JAPAN',\n                        'HONGKONG', 'FRANCE', 'ITALY', 'SPAIN', 'GERMANY', 'POLAND', 'CANADA', 'MEXICO'],\n['GALILEO', 'NEWTON', 'HUBBLE', 'ARECIBO', 'WEBB', 'CANADARM', 'ZARYA', 'POISK', 'RASSVET', 'BEAM', 'HARMONY',\n                        'UNITY', 'DESTINY', 'NAUKA', 'NICER', 'DEXTRE', 'BISHOP', 'KERBAL', 'PRICHAL'],\n['SOCCER', 'HOCKEY', 'BASEBALL', 'FOOTBALL', 'RUGBY', 'CRICKET', 'TENNIS', 'SKIING',\n                    'CURLING', 'FENCING', 'GOFLING', 'SAILING', 'ROWING'],\n['OILERS', 'WHALERS', 'PENGUINS', 'KINGS', 'JETS', 'FLAMES', 'PANTHERS', 'KRAKEN', 'WILD', 'BRUINS', 'SABRES', 'CANUCKS', 'CAPITALS'],\n['APPLE', 'GOOGLE', 'SAMSUNG', 'TESLA', 'FORD', 'DISNEY', 'HASBRO', 'SONY', 'HILTON', 'MONDELEZ', 'INTEL',\n                    'NVIDIA', 'BOEING', 'TOYOTA', 'MATTEL', 'NIKE', 'AMAZON', 'HUAWEI'],\n['HAIDA', 'BISMARCK', 'YAMATO', 'HOOD', 'ROMA', 'IOWA', 'NIMITZ',\n                    'MIDWAY', 'FUBUKI', 'GEARING', 'HALLAND', 'VANGUARD'],\n['WARTHOG', 'ARROW', 'CANUCK', 'RAPTOR', 'HORNET', 'FALCON', 'TYPHOON', 'HARRIER',\n                        'RAFALE', 'EAGLE', 'HERCULES', 'MUSTANG', 'SPITFIRE', 'CORSAIR', 'OSPREY', 'SPIRIT', 'PREDATOR'],\n['TETRIS', 'STARFOX',\n                    'ZELDA', 'DESTINY', 'POKEMON', 'PACMAN', 'FROGGER', 'ARK', 'DOTA'],\n['THORN', 'OSA', 'ARUNI', 'IANA', 'WARDEN', 'NOMAD', 'KAID', 'LION', 'FINKA', 'DOKKAEBI', 'YING', 'LESION',\n                    'JACKAL', 'BUCK', 'FROST', 'MUTE', 'SMOKE', 'ASH', 'CASTLE', 'MONTAGNE', 'FUZE', 'KAPKAN', 'AZAMI'],\n['RED', 'ORANGE', 'YELLOW', 'GREEN', 'BLUE', 'PURPLE', 'BROWN', 'BLACK', 'CYAN', 'MAGENTA',\n                    'CRIMSON', 'LIME', 'INDIGO', 'MAROON', 'AMBER', 'SCARLET', 'MUSTARD'],\n['PARASAUR', 'RAPTOR', 'BARYONYX', 'TROODON'],\n['LASAGNA', 'QUINOA', 'CHICKEN', 'LIME', 'POUTINE', 'BURRITO', 'FAJITAS', 'CORN',\n                    'SHRIMP', 'MACARONS', 'YAKITORI', 'ONIGIRI']\n]\n\nconst cellDims = 50; // Size of a cell\nconst matX = 250; // Matrix x offset\nconst matY = 50; // Matrix y offset\nconst BOARD_SIZE = 10; // Size of game matrix\nexport class WordSearch{\n    constructor(vuePage){\n        this.rows = BOARD_SIZE; // Number of rows in Matrix\n        this.cols = BOARD_SIZE; // Number of columns in Matrix\n        this.activeWords = [];  // Words for the current game\n        this.activeMatrix = []; // Matrix containing the game board\n        this.wordsFound = []; // Words found already\n        this.lastCell = null; // Previously selected cell\n        this.currentCell = null; // Currently selected cell\n        this.currentSelection = null; // Array of selected cells\n        this.over = false; // Stores the state of completion for the game\n        this.updateBoard(); \n        this.vuePage = vuePage; // Stored reference of Vue Page for accessing variables\n        this.started = false; \n        this.startedTime = 0; // 0 is placeholder value, stores seconds since EPOCH when the game starts\n        \n        // Setup the timer for the game\n        setInterval(() => {\n            if (this.started && !this.over){\n                this.vuePage.time = Math.round(new Date().getTime() / 1000) - this.startedTime;\n            }\n        }, 1000); // Update timer every second\n        const sketch = (s) => {\n\n            // create canvas area\n            s.setup = () => {\n                s.createCanvas(1200, 800).parent(\"game\");\n            }\n\n\n            s.draw = () => {\n                if (this.over){\n                    return;\n                }\n                s.clear();\n\n                this.drawBackground(); // works\n\n                this.drawMatrix();\n                this.drawSelection();\n                this.drawWords(); // works\n\n                this.inputHandler();\n            }\n\n            /*\n             * Name: drawBackground\n             * Description: Changes the background colour for the display\n             * Return: None\n            */\n            // used to display background colour\n            this.drawBackground = () => {\n                s.background(255, 255, 255); // white\n            }\n\n            /*\n             * Name: drawMatrix\n             * Description: Displays the matrix on the screen\n             * Return: None\n            */   \n            this.drawMatrix = () => {\n                s.push();\n\n                s.textAlign(s.CENTER, s.CENTER);\n                for (let row = 0; row < this.activeMatrix.length; row++) {\n                    let activeRow = this.activeMatrix[row];\n                    for (let col = 0; col < activeRow.length; col++) {\n                        let character = activeRow[col];\n\n                        let x = matX + col * cellDims;\n                        let y = matY + row * cellDims;\n\n                        s.stroke(0);\n\n                        // set colour of block:\n                        // if characters are highlighted, highlight colour is Fuchsia\n                        // if is a word, colour set to green\n                        // if not a word, turns back to white\n                        let colour = this.isSelected(row, col) ? \"Fuchsia\" : (this.foundCell(row, col) ? \"Lime\" : \"White\");\n                        s.fill(colour);\n                        s.rect(x, y, cellDims, cellDims);\n\n                        s.noStroke();\n                        s.fill(0);\n                        s.text(character, x + cellDims / 2, y + cellDims / 2);\n\n                    }\n                }\n\n                s.pop();\n            }\n\n            /*\n             * Name: drawSelection\n             * Description: Displays the selected words at the bottom\n             * Return: None\n            */\n            this.drawSelection = () => {\n                let txt = this.selectedWord();\n\n                // if there is no selected word, return\n                if (!txt) { return; }\n\n                s.push();\n                s.noStroke();\n                s.fill(0);\n                s.textSize(20);\n                s.text(txt, matX, matY + (this.rows + 1) * cellDims);\n                s.pop();\n            }\n\n            /*\n             * Name: drawWords\n             * Description: Display the words to find\n             * Return: None\n            */\n            this.drawWords = () => {\n                s.push();\n                s.noStroke();\n\n                for (let index = 0; index < this.activeWords.length; index++) {\n\n                    // makes a word in wordbank grey if found, else display as black\n                    s.fill(this.foundWord(this.activeWords[index]) ? \"Gray\" : \"Black\");\n                    s.text(this.activeWords[index], 30, matY + 20 + index * 50);\n\n                }\n\n                s.pop();\n            }\n            /*\n             * Name: checkMouse\n             * Description: Checks where the mouse is and selects cells\n             * Return: None\n            */\n            this.inputHandler = () => {\n                if (this.over){ return; }\n                // if mouse isn't pressed\n                if (!s.mouseIsPressed) {\n                    this.validateSelection();\n\n                    this.lastCell = null;\n                    this.currentCell = null;\n                    this.currentSelection = null;\n                    return;\n                }\n\n                // If not started then start the timer\n                if (!this.started){\n                    this.startedTime = Math.round(new Date().getTime() / 1000);\n                    this.started = true;\n                }\n\n                if (!this.lastCell) { this.lastCell = this.findCell(s.mouseX, s.mouseY); }\n\t\t\t\tlet nextCell = this.findCell(s.mouseX, s.mouseY);\n\n                if (nextCell) { this.currentCell = nextCell; }\n                this.currentSelection = this.findSelection();\n            }\n        };\n\n        this.sketch = new p5(sketch);\n    }\n\n    /*\n     * Name: reset\n     * Description: Resets the program including all necessary variables\n     * Return: None\n    */\n    reset(){\n        this.activeWords = [];\n        this.activeMatrix = [];\n        this.wordsFound = [];\n        this.lastCell = null;\n        this.currentCell = null;\n        this.currentSelection = null;\n        this.over = false;\n        this.updateBoard();\n        this.started = false;\n        this.startedTime = 0;\n        this.over = false;\n    }\n\n    /*\n     * Name: updateBoard\n     * Description: Sets the words and the matrix \n     * Return: None\n    */\n    updateBoard() {\n        this.activeWords = WORD_SELECTIONS[Math.floor(Math.random() * WORD_SELECTIONS.length)].sort((w1, w2) => Math.floor(Math.random() * (w1 + w2)) % 2 == 0).slice(0, 5);\n        this.activeMatrix = this.genMatrix(this.activeWords);\n    }\n\n    /*\n     * Name: genMatrix\n     * Description: Randomly generates a matrix for the game and inserts the words\n     * Return: 2D array of letters\n    */\n    genMatrix(activeWords){\n        // Generates a randoom letter\n        let randomLetter = () => [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"][Math.floor(Math.random() * 26)];\n        \n        // Set up basic matrix\n        let activeMatrix = [];\n        for (let i = 0; i < this.rows; i++){\n            activeMatrix.push([]);\n            for (let j = 0; j < this.cols; j++){\n                activeMatrix[i][j] = randomLetter();\n            }\n        }\n\n        // Add in active words\n        let occupiedSquares = [];\n        let checkOccupiedSquares = (ch, row, col) => {\n            for (let i = 0; i < occupiedSquares.length; i++){\n                let occupiedSquare = occupiedSquares[i];\n                let oRow = occupiedSquare.row;\n                let oCol = occupiedSquare.col;\n                // if square in array doesn't match desired square then skip\n                if (row != oRow || col != oCol){ continue; }\n                // else referring to same square\n                let oChar = occupiedSquare.char;\n                return oChar != ch; // if different characters then return false\n            }\n            return false;\n        }\n        let placeHorizontal = (word, row, col, reverse) => {\n            let curIndex = 0;\n            let dir = 1;\n            if (reverse){\n                curIndex = word.length - 1;\n                dir = -1;\n            }\n            let endCol = col + dir * word.length;\n            \n            if (endCol < 0 || endCol > this.cols){ return false; }\n\n            // Check if can place word in the spot\n            let nCol = col;\n            let nCurIndex = curIndex;\n            while(nCol != endCol){\n                let ch = word[nCurIndex];\n                if (checkOccupiedSquares(ch, row, nCol)){ return false; }\n                nCol += dir;\n                nCurIndex += dir;\n            }\n\n            // Place the word\n            nCol = col;\n            nCurIndex = curIndex;\n            while(nCol != endCol){\n                let ch = word[nCurIndex];\n                activeMatrix[row][nCol] = ch;\n                occupiedSquares.push({\"row\": row, \"col\": nCol, \"char\": ch})\n                nCol += dir;\n                nCurIndex += dir;\n            }\n            return true;\n\n        }\n        let placeVertical = (word, row, col, reverse) => {\n            let curIndex = 0;\n            let dir = 1;\n            if (reverse){\n                dir = -1;\n            }\n            let endRow = row + dir * word.length;\n            \n            if (endRow < 0 || endRow > this.rows){ return false; }\n\n            // Check if can place word in the spot\n            let nRow = row;\n            let nCurIndex = curIndex;\n            while(nRow != endRow){\n                let ch = word[nCurIndex];\n                if (checkOccupiedSquares(ch, nRow, col)){ return false; }\n                nRow += dir;\n                nCurIndex += 1;\n            }\n\n            // Place the word\n            nRow = row;\n            nCurIndex = curIndex;\n            while(nRow != endRow){\n                let ch = word[nCurIndex];\n                activeMatrix[nRow][col] = ch;\n                occupiedSquares.push({\"row\": nRow, \"col\": col, \"char\": ch})\n                nRow += dir;\n                nCurIndex += 1;\n            }\n            return true;\n\n        }\n        let placeDiagonal = (word, row, col, reverse) =>{\n            let curIndex = 0;\n            let dir = 1;\n            if (reverse){\n                dir = -1;\n            }\n            let endRow = row + dir * word.length;\n            let endCol = col + dir * word.length;\n            if (endRow < 0 || endRow > this.rows){ return false; }\n            if (endCol < 0 || endCol > this.cols) { return false; }\n\n            // Check if can place word in the spot\n            let nRow = row;\n            let nCol = col;\n            let nCurIndex = curIndex;\n            while(nRow != endRow && nCol != endCol){\n                let ch = word[nCurIndex];\n                if (checkOccupiedSquares(ch, nRow, nCol)){ return false; }\n                nRow += dir;\n                nCol += dir;\n                nCurIndex += 1;\n            }\n\n            // Place the word\n            nRow = row;\n            nCol = col;\n            nCurIndex = curIndex;\n            while(nRow != endRow && nCol != endCol){\n                let ch = word[nCurIndex];\n                activeMatrix[nRow][nCol] = ch;\n                occupiedSquares.push({\"row\": nRow, \"col\": nCol, \"char\": ch})\n                nRow += dir;\n                nCol += dir;\n                nCurIndex += 1;\n            }\n            return true;\n        }\n        // Array to select functions from\n        let placementFunctions = [placeHorizontal, placeVertical, placeDiagonal];\n        const numAttempts = 500; // imperfect solution to prevent infinite looping\n        let words2Pop = [];\n        for (let i = 0; i < activeWords.length; i++){\n            let activeWord = activeWords[i];\n            let attempted = 0;\n            while(attempted < numAttempts){\n                let pRow = Math.floor(Math.random() * this.rows);\n                let pCol = Math.floor(Math.random() * this.cols);\n                let pFIndex = Math.floor(Math.random() * 3);\n                let reverse = Math.floor(Math.random() * 2) == 0;\n                let placementFunction = placementFunctions[pFIndex];\n                let result = placementFunction(activeWord, pRow, pCol, reverse);\n                if (result){\n                    break;\n                }\n                attempted++;\n            }\n\n            // If max attempts then need to remove word from game because couldn't place it\n            if (attempted == numAttempts){\n                words2Pop.push(i);\n            }\n            // On last word and no words placed yet\n            if (i == activeWords.length - 1 && words2Pop.length == activeWords.length){\n                placeHorizontal(activeWord, 0, 0, false);\n            }\n        }\n\n        words2Pop.reverse();\n\n        // Remove unplaced words\n        for (let i = 0; i < words2Pop.length; i++){\n            this.activeWords.pop(words2Pop[i]);\n        }\n\n        return activeMatrix;\n    }\n\n    /*\n     * Name: isOver\n     * Description: makes over = true\n     * Return: Noen\n    */\n    isOver(){\n        return this.over;\n    }\n\n    /*\n     * Name: validateSelection\n     * Description: On mouse release, checks if previously highlighted characters form a word\n     * If word is formed, checks if word is a part of the word list\n     * If user found word in list, will record word found and mark as found\n     * Return: None\n    */\n    validateSelection() {\n\n        let word = this.selectedWord();\n\n        // exits if no word\n        if (!word) { return; }\n\n        // exits if\n        if (this.foundWord(word)) { return; }\n\n        // records word as found if word was found\n        if (this.activeWords.includes(word)) { this.addFound(word, this.currentSelection); }\n\n        // If the game is over\n        if (this.wordsFound.length === this.activeWords.length) {\n            // stop timer\n            this.over = true;\n            // record score\n            accessHighscores.updateHighscores(this.calculateHighscore(Math.round(new Date().getTime() / 1000) - this.startedTime), prompt(\"You Win! Please enter username:\"), \"word_search\");\n            this.reset();\n        }\n\n    }\n\n    /*\n     * Name: calculateHighscore\n     * Description: Calculates the highscore of a game based on the duration and length of words\n     * Return: Score (int)\n    */\n    calculateHighscore(duration){\n        const MAX_SCORE_DURATION = 1000; // Max duration after which score is not affected\n        const SCORE_DURATION_COEFFICIENT = 10;\n        let c = 0;\n        for (let i = 0; i < this.activeWords.length; i++){\n            c += this.activeWords[i].length;\n        }\n        return Math.ceil(c * Math.max(1, (MAX_SCORE_DURATION - duration) * SCORE_DURATION_COEFFICIENT));\n    }\n\n    /*\n     * Name: findCell\n     * Description: Returns cell information at a given pixel\n     * Return: An object with cell coordinates\n    */\n    findCell(x, y) {\n        let colIndex = Math.floor((x - matX) / cellDims);\n        let rowIndex = Math.floor((y - matY) / cellDims);\n\n        // if out of bounds of grid, return null\n        if (colIndex < 0 || colIndex >= this.cols || rowIndex < 0 || rowIndex >= this.rows) { return null; }\n\n        // if there are valid indices, return the row and column\n        return { \"row\": rowIndex, \"col\": colIndex};\n    }\n\n    /*\n     * Name: selectedWord\n     * Description: Retrives the selected word\n     * Return: String\n    */\n    selectedWord() {\n\n        // if there is no current selection, return blank\n        if (!this.currentSelection) { return \"\"; }\n\n        let txt= \"\";\n\n        for (let value of this.currentSelection) { txt += value.character; }\n\n        return txt;\n\n    }\n\n    /*\n     * Function used to check if currently selected characters\n     * are horizontal, vertical, or diagonal, and will return\n     * array of currently highlighted characters\n     */\n    findSelection() {\n\n        // if there is one or no cells selected, will return null\n        if (!this.lastCell || !this.currentCell) { return null; }\n\n        // execute functions in if else order\n        // if hSelection is null, run vSelection, if not null, end;\n        return this.horizontalSelection() || this.verticalSelection() || this.diagonalSelection();\n\n    }\n\n    /*\n     * Checks to see if selected cells are in horizontal line\n     * returns array of currently selected horizontal characters\n     */\n    horizontalSelection() {\n\n        // if either last cell or current cell are null, return null\n        if (!this.lastCell || !this.currentCell) { return null; }\n\n        // if selection isn't horizontal, exit and go to next checker function\n        if (this.lastCell.row != this.currentCell.row) { return null; }\n\n        let characterArray = [];\n\n        let delta = this.lastCell.col <= this.currentCell.col ? 1 : -1;\n\n        for (let col = this.lastCell.col; col != this.currentCell.col + delta; col += delta) {\n\n            let row = this.lastCell.row;\n            let character = this.activeMatrix[row][col];\n\n            characterArray.push( { \"row\": row, \"col\": col, \"character\": character } );\n\n        }\n\n        return characterArray;\n\n    }\n\n    /*\n     * Checks to see if selected cells are in vertical line\n     */\n    verticalSelection() {\n\n        // if either last cell or current cell are null, return null\n        if (!this.lastCell || !this.currentCell) { return null; }\n\n        // if the selection isn't vertical,\n        // return null and pass to diagonal checker function\n        if (this.lastCell.col != this.currentCell.col) { return null; }\n\n        let characterArray = [];\n\n        let delta = this.lastCell.row <= this.currentCell.row ? 1 : -1;\n\n        for (let row = this.lastCell.row; row != this.currentCell.row + delta; row += delta) {\n\n            let col = this.lastCell.col;\n            let character = this.activeMatrix[row][col];\n\n            characterArray.push( { \"row\": row, \"col\": col, \"character\": character } );\n\n        }\n\n        return characterArray;\n\n    }\n\n    /*\n     * Checks to see if the user is highlighting the characters\n     * in a diagonal line. If they aren't, function will stop\n     * user from highlighting characters in a random order\n     */\n    diagonalSelection() {\n\n        if (!this.lastCell || !this.currentCell) { return null; }\n\n        // if successive selected cells are not diagonal, exits returning null\n        if (Math.abs(this.currentCell.row - this.lastCell.row) != Math.abs(this.currentCell.col - this.lastCell.col)) { return null; }\n\n        let characterArray = [];\n\n        let dHorizontal = this.lastCell.col <= this.currentCell.col ? 1 : -1;\n        let dVertical = this.lastCell.row <= this.currentCell.row ? 1 : -1;\n\n        let row = this.lastCell.row;\n        let col = this.lastCell.col;\n\n\n\n        while (row != this.currentCell.row + dVertical && col != this.currentCell.col + dHorizontal) {\n\n            let character = this.activeMatrix[row][col];\n\t\t\tcharacterArray.push({ \"row\": row, \"col\": col, \"character\": character });\n\t\t\trow += dVertical;\n\t\t\tcol += dHorizontal;\n\n        }\n        return characterArray;\n     \n    }\n\n    /*\n     * Name: isSelected\n     * Description: Checks if a given cell is selected\n     * Return: True if selected, else false\n    */\n    isSelected(row, col) {\n\n        if (!this.currentSelection) { return false; }\n\n        for (let value of this.currentSelection) {\n\n            if (value.row === row && value.col === col) { return true; }\n\n        }\n\n        return false;\n\n    }\n\n    /*\n     * Name: addFound\n     * Description: Adds a word to the list of words found\n     * Return: None\n    */\n    addFound(word, cells) { this.wordsFound.push( { \"word\": word, \"cells\": cells } ); }\n\n    /*\n     * Name: foundWord\n     * Description: Checks if a word has been found\n     * Return: True if found, else false\n    */\n    foundWord(word) {\n        for (let value of this.wordsFound) {\n            if (value.word === word) { return true; }\n        }\n\n        return false;\n    }\n\n    /*\n     * Name: foundCell\n     * Description: Checks if a word has been found that includes that cell\n     * Return: True if found, else false\n    */\n    foundCell(row, col) {\n        for (let value of this.wordsFound) {\n            for (let valueCell of value.cells) {\n                if (valueCell.row === row && valueCell.col === col) { return true; }\n            }\n        }\n\n        return false;\n\n    }\n}\n","import { render } from \"./WordSearchGame.vue?vue&type=template&id=2226dcfb\"\nimport script from \"./WordSearchGame.vue?vue&type=script&lang=js\"\nexport * from \"./WordSearchGame.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"/mnt/d/School/WebDevGroupProject/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { render } from \"./WordSearchView.vue?vue&type=template&id=1f361f92\"\nimport script from \"./WordSearchView.vue?vue&type=script&lang=js\"\nexport * from \"./WordSearchView.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"/mnt/d/School/WebDevGroupProject/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__"],"names":["class","_createElementVNode","_createElementBlock","_hoisted_2","_createVNode","_component_WordSearchGame","id","_hoisted_1","_toDisplayString","$data","onClick","$options","WORD_SELECTIONS","cellDims","matX","matY","BOARD_SIZE","WordSearch","constructor","vuePage","this","rows","cols","activeWords","activeMatrix","wordsFound","lastCell","currentCell","currentSelection","over","updateBoard","started","startedTime","setInterval","time","Math","round","Date","getTime","sketch","s","setup","createCanvas","parent","draw","clear","drawBackground","drawMatrix","drawSelection","drawWords","inputHandler","background","push","textAlign","CENTER","row","length","activeRow","col","character","x","y","stroke","colour","isSelected","foundCell","fill","rect","noStroke","text","pop","txt","selectedWord","textSize","index","foundWord","mouseIsPressed","validateSelection","findCell","mouseX","mouseY","nextCell","findSelection","p5","reset","floor","random","sort","w1","w2","slice","genMatrix","randomLetter","i","j","occupiedSquares","checkOccupiedSquares","ch","occupiedSquare","oRow","oCol","oChar","char","placeHorizontal","word","reverse","curIndex","dir","endCol","nCol","nCurIndex","placeVertical","endRow","nRow","placeDiagonal","placementFunctions","numAttempts","words2Pop","activeWord","attempted","pRow","pCol","pFIndex","placementFunction","result","isOver","includes","addFound","accessHighscores","calculateHighscore","prompt","duration","MAX_SCORE_DURATION","SCORE_DURATION_COEFFICIENT","c","ceil","max","colIndex","rowIndex","value","horizontalSelection","verticalSelection","diagonalSelection","characterArray","delta","abs","dHorizontal","dVertical","cells","valueCell","name","data","game","boardSize","methods","startup","aws","mounted","$nextTick","__exports__","title","components","WordSearchGame","render"],"sourceRoot":""}